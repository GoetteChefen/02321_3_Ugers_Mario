//interrupt handler for btns
#include "interuptIO.h"


XScuGic INTCInst;
XTmrCtr TMRInst;

XGpio SWITCHInst, BTNInst, LEDInst;



//initialise interupts for everything (call this in main)

void initialiseIOandInterupts(){
	//----------------------------------------------------
	// INITIALIZE THE PERIPHERALS & SET DIRECTIONS OF GPIO
	//----------------------------------------------------
	int status;

	// Initialise LEDs
	status = XGpio_Initialize(&LEDInst, LEDS_DEVICE_ID);
	if(status != XST_SUCCESS) return XST_FAILURE;

    // Initialise Push Buttons
	status = XGpio_Initialize(&BTNInst, BTNS_DEVICE_ID);
	if(status != XST_SUCCESS) return XST_FAILURE;

    // Initialise Switches

	status = XGpio_Initialize(&SWITCHInst, SWITCH_DEVICE_ID);
    if(status != XST_SUCCESS) return XST_FAILURE;

    // Set LEDs direction to outputs
    XGpio_SetDataDirection(&LEDInst, 1, 0x00);
    // Set all buttons direction to inputs
    XGpio_SetDataDirection(&BTNInst, 1, 0xFF);
    // Set all switches direction to inputs
    XGpio_SetDataDirection(&SWITCHInst, 1, 0xFF);

    //----------------------------------------------------
    // SETUP THE TIMER
    //----------------------------------------------------
	status = XTmrCtr_Initialize(&TMRInst, TMR_DEVICE_ID);
	if(status != XST_SUCCESS) return XST_FAILURE;

	XTmrCtr_SetHandler(&TMRInst, TMR_Intr_Handler, &TMRInst);

	XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD);
	XTmrCtr_SetResetValue(&TMRInst, 1, TMR_LOAD_1);

	XTmrCtr_SetOptions(&TMRInst, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION);
	XTmrCtr_SetOptions(&TMRInst, 1, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION);



	// Initialize interrupt controller
	status = IntcInitFunction(INTC_DEVICE_ID, &TMRInst, &BTNInst);

	if(status != XST_SUCCESS) return XST_FAILURE;

	 XTmrCtr_Start(&TMRInst, 0);
	  //Here we get the time when the timer first started



}


void TMR_Intr_Handler(void *InstancePtr, u8 TmrCtrNumber){

    XTmrCtr* pTMRInst = (XTmrCtr *) InstancePtr;

    //xil_printf("Timer %d interrupt \n\r", TmrCtrNumber);



    if (TmrCtrNumber==0) { //Handle interrupts generated by timer 0 (frame)
    	 if (XTmrCtr_IsExpired(pTMRInst,0)){
    		 // Once timer has expired 1 time, stop, increment counter
    		 // reset timer and start running again

    		 XTmrCtr_Stop(pTMRInst,0);
    		 tmr_flag = 1;


    		 XTmrCtr_Reset(pTMRInst,0);
    		 XTmrCtr_Start(pTMRInst,0);
    	 }




    }
    else{  // state==Stopwatch Handle interrupts generated by timer 1


    }

    XTmrCtr_ClearInterruptFlag(pTMRInst, TmrCtrNumber);
}



int InterruptSystemSetup(XScuGic *XScuGicInstancePtr){
    // Enable interrupt for buttons
    XGpio_InterruptEnable(&BTNInst, BTN_INT);
    XGpio_InterruptGlobalEnable(&BTNInst);

    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 XScuGicInstancePtr);
    Xil_ExceptionEnable();


    return XST_SUCCESS;

}



void XTmrCtr_ClearInterruptFlag(XTmrCtr * InstancePtr, u8 TmrCtrNumber)
{
    u32 CounterControlReg;

    Xil_AssertVoid(InstancePtr != NULL);
    Xil_AssertVoid(TmrCtrNumber < XTC_DEVICE_TIMER_COUNT);
    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

    /*
     * Read current contents of the CSR register so it won't be destroyed
     */
    CounterControlReg = XTmrCtr_ReadReg(InstancePtr->BaseAddress,
                                        TmrCtrNumber, XTC_TCSR_OFFSET);
    /*
     * Reset the interrupt flag
     */
    XTmrCtr_WriteReg(InstancePtr->BaseAddress, TmrCtrNumber,
                     XTC_TCSR_OFFSET,
                     CounterControlReg | XTC_CSR_INT_OCCURED_MASK);
}




void BTN_Intr_Handler(void *InstancePtr) {
    // Disable GPIO interrupts
    XGpio_InterruptDisable(&BTNInst, BTN_INT);


    // Ignore additional button presses
    if ((XGpio_InterruptGetStatus(&BTNInst) & BTN_INT) != BTN_INT) {
        return;
    }

    btn_value = XGpio_DiscreteRead(&BTNInst, 1);

    btn_flag = 1;

    //----------------------------------------------------------------------------------------------------------------------
    XGpio_DiscreteWrite(&LEDInst, 1, btn_value);
    //----------------------------------------------------------------------------------------------------------------------

    (void)XGpio_InterruptClear(&BTNInst, BTN_INT);
    // Enable GPIO interrupts
    XGpio_InterruptEnable(&BTNInst, BTN_INT);
}


int IntcInitFunction(u16 DeviceId, XTmrCtr *TmrInstancePtr, XGpio *GpioInstancePtr)
{
	XScuGic_Config *IntcConfig;
	int status;
	u8 pri, trig;

	// Interrupt controller initialisation
	IntcConfig = XScuGic_LookupConfig(DeviceId);
	status = XScuGic_CfgInitialize(&INTCInst, IntcConfig, IntcConfig->CpuBaseAddress);
	if(status != XST_SUCCESS) return XST_FAILURE;

	// Call to interrupt setup
	status = InterruptSystemSetup(&INTCInst);
	if(status != XST_SUCCESS) return XST_FAILURE;

	// Connect GPIO buttons interrupt to handler
	status = XScuGic_Connect(&INTCInst,
					  	  	 INTC_GPIO_INTERRUPT_ID,
					  	  	 (Xil_ExceptionHandler)BTN_Intr_Handler,
					  	  	 (void *)GpioInstancePtr);
	if(status != XST_SUCCESS) return XST_FAILURE;


	// Connect timer interrupt to handler
	status = XScuGic_Connect(&INTCInst,
							 INTC_TMR_INTERRUPT_ID,
							// (Xil_ExceptionHandler)TMR_Intr_Handler,
							 (Xil_ExceptionHandler) XTmrCtr_InterruptHandler,
							 (void *)TmrInstancePtr);
	if(status != XST_SUCCESS) return XST_FAILURE;

	// Enable GPIO interrupts interrupt
	XGpio_InterruptEnable(GpioInstancePtr, 1);
	XGpio_InterruptGlobalEnable(GpioInstancePtr);

	// Enable GPIO and timer interrupts in the controller
	XScuGic_Enable(&INTCInst, INTC_GPIO_INTERRUPT_ID);
	XScuGic_Enable(&INTCInst, INTC_TMR_INTERRUPT_ID);

	xil_printf("Getting the Timer interrupt info\n\r");
	XScuGic_GetPriTrigTypeByDistAddr(INTCInst.Config->DistBaseAddress, INTC_TMR_INTERRUPT_ID, &pri, &trig);
	xil_printf("GPIO Interrupt-> Priority:%d, Trigger:%x\n\r", pri, trig);


	//Set the timer interrupt as edge triggered
	XScuGic_SetPriorityTriggerType(&INTCInst, INTC_TMR_INTERRUPT_ID, pri, trig);

	return XST_SUCCESS;
}
